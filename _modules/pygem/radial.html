

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pygem.radial &mdash; PyGeM 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyGeM 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyGeM
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Code Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../LICENSE.html">License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyGeM</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>pygem.radial</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pygem.radial</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module focused on the implementation of the Radial Basis Functions interpolation technique.</span>
<span class="sd">This technique is still based on the use of a set of parameters, the so-called control points,</span>
<span class="sd">as for FFD, but RBF is interpolatory. Another important key point of RBF strategy relies in the</span>
<span class="sd">way we can locate the control points: in fact, instead of FFD where control points need to be</span>
<span class="sd">placed inside a regular lattice, with RBF we hano no more limitations. So we have the possibility</span>
<span class="sd">to perform localized control points refiniments.</span>
<span class="sd">The module is analogous to the freeform one.</span>

<span class="sd">:Theoretical Insight:</span>

<span class="sd">	As reference please consult M.D. Buhmann, Radial Basis Functions, volume 12 of Cambridge</span>
<span class="sd">	monographs on applied and computational mathematics. Cambridge University Press, UK, 2003.</span>
<span class="sd">	This implementation follows D. Forti and G. Rozza, Efficient geometrical parametrization techniques</span>
<span class="sd">	of interfaces for reduced order modelling: application to fluid-structure interaction coupling problems,</span>
<span class="sd">	International Journal of Computational Fluid Dynamics.</span>
<span class="sd">	</span>
<span class="sd">	RBF shape parametrization technique is based on the definition of a map,</span>
<span class="sd">	:math:`\\mathcal{M}(\\boldsymbol{x}) : \\mathbb{R}^n \\rightarrow \\mathbb{R}^n`, that allows the</span>
<span class="sd">	possibility of transferring data across non-matching grids and facing the dynamic mesh handling.</span>
<span class="sd">	The map introduced is defines as follows</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\mathcal{M}(\\boldsymbol{x}) = p(\\boldsymbol{x}) + \\sum_{i=1}^{\\mathcal{N}_C} \\gamma_i</span>
<span class="sd">		\\varphi(\\| \\boldsymbol{x} - \\boldsymbol{x_{C_i}} \\|)</span>

<span class="sd">	where :math:`p(\\boldsymbol{x})` is a low_degree polynomial term, :math:`\\gamma_i` is the weight,</span>
<span class="sd">	corresponding to the a-priori selected :math:`\\mathcal{N}_C` control points, associated to the</span>
<span class="sd">	:math:`i`-th basis function, and :math:`\\varphi(\\| \\boldsymbol{x} - \\boldsymbol{x_{C_i}} \\|)`</span>
<span class="sd">	a radial function based on the Euclidean distance between the control points position</span>
<span class="sd">	:math:`\\boldsymbol{x_{C_i}}` and :math:`\\boldsymbol{x}`. A radial basis function, generally, is</span>
<span class="sd">	a real-valued function whose value depends only on the distance from the origin, so that</span>
<span class="sd">	:math:`\\varphi(\\boldsymbol{x}) = \\tilde{\\varphi}(\\| \\boldsymbol{x} \\|)`.</span>

<span class="sd">	The matrix version of the formula above is:</span>

<span class="sd">	.. math::</span>
<span class="sd">		\\mathcal{M}(\\boldsymbol{x}) = \\boldsymbol{c} + \\boldsymbol{Q}\\boldsymbol{x} +</span>
<span class="sd">		\\boldsymbol{W^T}\\boldsymbol{d}(\\boldsymbol{x})</span>

<span class="sd">	The idea is that after the computation of the weights and the polynomial terms from the coordinates</span>
<span class="sd">	of the control points before and after the deformation, we can deform all the points of the mesh</span>
<span class="sd">	accordingly.</span>
<span class="sd">	Among the most common used radial basis functions for modelling 2D and 3D shapes, we consider</span>
<span class="sd">	Gaussian splines, Multi-quadratic biharmonic splines, Inverted multi-quadratic biharmonic splines,</span>
<span class="sd">	Thin-plate splines and Beckert and Wendland :math:`C^2` basis all defined and implemented below.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="k">import</span> <span class="n">cdist</span>


<div class="viewcode-block" id="RBF"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF">[docs]</a><span class="k">class</span> <span class="nc">RBF</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Class that handles the Radial Basis Functions interpolation on the mesh points.</span>

<span class="sd">	:param RBFParameters rbf_parameters: parameters of the RBF.</span>
<span class="sd">	:param numpy.ndarray original_mesh_points: coordinates of the original points of the mesh.</span>

<span class="sd">	:cvar RBFParameters parameters: parameters of the RBF.</span>
<span class="sd">	:cvar numpy.ndarray original_mesh_points: coordinates of the original points of the mesh.</span>
<span class="sd">		The shape is `n_points`-by-3.</span>
<span class="sd">	:cvar numpy.ndarray modified_mesh_points: coordinates of the points of the deformed mesh.</span>
<span class="sd">		The shape is `n_points`-by-3.</span>
<span class="sd">	:cvar dict bases: a dictionary that associates the names of the basis functions</span>
<span class="sd">		implemented to the actual implementation.</span>
<span class="sd">	:cvar numpy.matrix weights: the matrix formed by the weights corresponding to the a-priori</span>
<span class="sd">		selected N control points, associated to the basis functions and c and Q terms that</span>
<span class="sd">		describe the polynomial of order one p(x) = c + Qx. The shape is</span>
<span class="sd">		(n_control_points+1+3)-by-3. It is computed internally.</span>

<span class="sd">	:Example:</span>

<span class="sd">	&gt;&gt;&gt; import pygem.radial as rbf</span>
<span class="sd">	&gt;&gt;&gt; import pygem.params as rbfp</span>
<span class="sd">	&gt;&gt;&gt; import numpy as np</span>

<span class="sd">	&gt;&gt;&gt; rbf_parameters = rbfp.RBFParameters()</span>
<span class="sd">	&gt;&gt;&gt; rbf_parameters.read_parameters(&#39;tests/test_datasets/parameters_rbf_cube.prm&#39;)</span>

<span class="sd">	&gt;&gt;&gt; nx, ny, nz = (20, 20, 20)</span>
<span class="sd">	&gt;&gt;&gt; mesh = np.zeros((nx * ny * nz, 3))</span>
<span class="sd">	&gt;&gt;&gt; xv = np.linspace(0, 1, nx)</span>
<span class="sd">	&gt;&gt;&gt; yv = np.linspace(0, 1, ny)</span>
<span class="sd">	&gt;&gt;&gt; zv = np.linspace(0, 1, nz)</span>
<span class="sd">	&gt;&gt;&gt; z, y, x = np.meshgrid(zv, yv, xv)</span>
<span class="sd">	&gt;&gt;&gt; mesh = np.array([x.ravel(), y.ravel(), z.ravel()])</span>
<span class="sd">	&gt;&gt;&gt; original_mesh_points = mesh.T</span>

<span class="sd">	&gt;&gt;&gt; radial_trans = rbf.RBF(rbf_parameters, original_mesh_points)</span>
<span class="sd">	&gt;&gt;&gt; radial_trans.perform()</span>
<span class="sd">	&gt;&gt;&gt; new_mesh_points = radial_trans.modified_mesh_points</span>
<span class="sd">	&quot;&quot;&quot;</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rbf_parameters</span><span class="p">,</span> <span class="n">original_mesh_points</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">rbf_parameters</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_points</span> <span class="o">=</span> <span class="n">original_mesh_points</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">modified_mesh_points</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gaussian_spline&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian_spline</span><span class="p">,</span> \
		 <span class="s1">&#39;multi_quadratic_biharmonic_spline&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">multi_quadratic_biharmonic_spline</span><span class="p">,</span> \
		 <span class="s1">&#39;inv_multi_quadratic_biharmonic_spline&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">inv_multi_quadratic_biharmonic_spline</span><span class="p">,</span> \
		 <span class="s1">&#39;thin_plate_spline&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">thin_plate_spline</span><span class="p">,</span> \
		 <span class="s1">&#39;beckert_wendland_c2_basis&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beckert_wendland_c2_basis</span><span class="p">}</span>

		<span class="c1"># to make the str callable we have to use a dictionary with all the implemented</span>
		<span class="c1"># radial basis functions</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">basis</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;The name of the basis function in the parameters file is not correct &#39;</span> <span class="o">+</span> \
			  <span class="s1">&#39;or not implemented. Check the documentation for all the available functions.&#39;</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">original_control_points</span><span class="p">,</span> \
		 <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">deformed_control_points</span><span class="p">)</span>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RBF.gaussian_spline"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.gaussian_spline">[docs]</a>	<span class="k">def</span> <span class="nf">gaussian_spline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		It implements the following formula:</span>

<span class="sd">		.. math::</span>
<span class="sd">			\\varphi(\\| \\boldsymbol{x} \\|) = e^{-\\frac{\\| \\boldsymbol{x} \\|^2}{r^2}}</span>

<span class="sd">		:param numpy.ndarray X: the vector x in the formula above.</span>
<span class="sd">		:param float r: the parameter r in the formula above.</span>

<span class="sd">		:return: result: the result of the formula above.</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">norm</span> <span class="o">*</span> <span class="n">norm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span></div>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RBF.multi_quadratic_biharmonic_spline"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.multi_quadratic_biharmonic_spline">[docs]</a>	<span class="k">def</span> <span class="nf">multi_quadratic_biharmonic_spline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		It implements the following formula:</span>

<span class="sd">		.. math::</span>
<span class="sd">			\\varphi(\\| \\boldsymbol{x} \\|) = \\sqrt{\\| \\boldsymbol{x} \\|^2 + r^2}</span>

<span class="sd">		:param numpy.ndarray X: the vector x in the formula above.</span>
<span class="sd">		:param float r: the parameter r in the formula above.</span>

<span class="sd">		:return: result: the result of the formula above.</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">norm</span> <span class="o">*</span> <span class="n">norm</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">result</span></div>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RBF.inv_multi_quadratic_biharmonic_spline"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.inv_multi_quadratic_biharmonic_spline">[docs]</a>	<span class="k">def</span> <span class="nf">inv_multi_quadratic_biharmonic_spline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		It implements the following formula:</span>

<span class="sd">		.. math::</span>
<span class="sd">			\\varphi(\\| \\boldsymbol{x} \\|) = (\\| \\boldsymbol{x} \\|^2 + r^2 )^{-\\frac{1}{2}}</span>

<span class="sd">		:param numpy.ndarray X: the vector x in the formula above.</span>
<span class="sd">		:param float r: the parameter r in the formula above.</span>

<span class="sd">		:return: result: the result of the formula above.</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">norm</span> <span class="o">*</span> <span class="n">norm</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">result</span></div>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RBF.thin_plate_spline"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.thin_plate_spline">[docs]</a>	<span class="k">def</span> <span class="nf">thin_plate_spline</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		It implements the following formula:</span>

<span class="sd">		.. math::</span>
<span class="sd">			\\varphi(\\| \\boldsymbol{x} \\|) = \\left\\| \\frac{\\boldsymbol{x} }{r} \\right\\|^2</span>
<span class="sd">			\\ln \\left\\| \\frac{\\boldsymbol{x} }{r} \\right\\|</span>

<span class="sd">		:param numpy.ndarray X: the vector x in the formula above.</span>
<span class="sd">		:param float r: the parameter r in the formula above.</span>

<span class="sd">		:return: result: the result of the formula above.</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">arg</span> <span class="o">=</span> <span class="n">X</span> <span class="o">/</span> <span class="n">r</span>
		<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">*</span> <span class="n">norm</span>
		<span class="k">if</span> <span class="n">norm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">result</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span></div>

	<span class="nd">@staticmethod</span>
<div class="viewcode-block" id="RBF.beckert_wendland_c2_basis"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.beckert_wendland_c2_basis">[docs]</a>	<span class="k">def</span> <span class="nf">beckert_wendland_c2_basis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		It implements the following formula:</span>

<span class="sd">		.. math::</span>
<span class="sd">			\\varphi(\\| \\boldsymbol{x} \\|) = \\left( 1 - \\frac{\\| \\boldsymbol{x} \\|}{r} \\right)^4_+</span>
<span class="sd">			\\left( 4 \\frac{\\| \\boldsymbol{x} \\|}{r} + 1 \\right)</span>

<span class="sd">		:param numpy.ndarray X: the vector x in the formula above.</span>
<span class="sd">		:param float r: the parameter r in the formula above.</span>

<span class="sd">		:return: result: the result of the formula above.</span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
		<span class="n">arg</span> <span class="o">=</span> <span class="n">norm</span> <span class="o">/</span> <span class="n">r</span>
		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">arg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">arg</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">second</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">first</span> <span class="o">*</span> <span class="n">second</span>
		<span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="RBF._distance_matrix"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF._distance_matrix">[docs]</a>	<span class="k">def</span> <span class="nf">_distance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		This private method returns the following matrix:</span>
<span class="sd">		:math:`\\boldsymbol{D_{ij}} = \\varphi(\\| \\boldsymbol{x_i} - \\boldsymbol{y_j} \\|)`</span>

<span class="sd">		:param numpy.ndarray X1: the vector x in the formula above.</span>
<span class="sd">		:param numpy.ndarray X2: the vector y in the formula above.</span>

<span class="sd">		:return: matrix: the matrix D.</span>
<span class="sd">		:rtype: numpy.ndarray</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">matrix</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span>
				<span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">radius</span><span class="p">)</span>
		<span class="p">)</span>
		<span class="k">return</span> <span class="n">matrix</span></div>

<div class="viewcode-block" id="RBF._get_weights"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF._get_weights">[docs]</a>	<span class="k">def</span> <span class="nf">_get_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		This private method, given the original control points and the deformed ones, returns the matrix</span>
<span class="sd">		with the weights and the polynomial terms, that is :math:`W`, :math:`c^T` and :math:`Q^T`.</span>
<span class="sd">		The shape is (n_control_points+1+3)-by-3.</span>

<span class="sd">		:param numpy.ndarray X: it is an n_control_points-by-3 array with the</span>
<span class="sd">			coordinates of the original interpolation control points before the deformation.</span>
<span class="sd">		:param numpy.ndarray Y: it is an n_control_points-by-3 array with the</span>
<span class="sd">			coordinates of the interpolation control points after the deformation.</span>

<span class="sd">		:return: weights: the matrix with the weights and the polynomial terms.</span>
<span class="sd">		:rtype: numpy.matrix</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">n_points</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">dim</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
		<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">dist</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="n">X</span><span class="p">],</span> <span class="p">[</span><span class="n">identity</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))],</span> \
		 <span class="p">[</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))]])</span>
		<span class="n">rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">Y</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">dim</span><span class="p">))],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">))]])</span>
		<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">weights</span></div>

<div class="viewcode-block" id="RBF.perform"><a class="viewcode-back" href="../../radial.html#pygem.radial.RBF.perform">[docs]</a>	<span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		This method performs the deformation of the mesh points. After the execution</span>
<span class="sd">		it sets `self.modified_mesh_points`.</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">n_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_distance_matrix</span><span class="p">(</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">original_control_points</span>
		<span class="p">)</span>
		<span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bmat</span><span class="p">([[</span><span class="n">dist</span><span class="p">,</span> <span class="n">identity</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_mesh_points</span><span class="p">]])</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">modified_mesh_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">))</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Filippo Salmoiraghi, Marco Tezzele.
      Last updated on May 17, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>